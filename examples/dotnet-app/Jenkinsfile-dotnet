node {
    // --- Pipeline parameters to control Docker build behavior ---
    properties([parameters([
        booleanParam(name: 'USE_BUILDKIT', defaultValue: true,  description: 'Enable Docker BuildKit'),
        booleanParam(name: 'USE_BUILDX',   defaultValue: false, description: 'Use docker buildx explicitly (requires buildx plugin in agent)')
    ])])

    // === Image + App configuration ===
    def buildImage = 'agileqa/jenkins-agent:multi-tool'        // your toolbox image (now includes buildx)
    def repo       = 'agileqa/dotnet-sample'                   // Docker Hub app repo
    def tag        = env.IMAGE_TAG ?: 'latest'                 // image tag

    // .NET app layout in this repo
    def projDir    = 'examples/dotnet-app'                     // contains DotnetApp.csproj
    def dockerfile = 'examples/dotnet-app/Dockerfile'          // app Dockerfile
    def buildCtx   = '.'                                       // keep root context

    // Host-side NuGet HOME under workspace (will be mounted later)
    def nugetHomeHost = "${env.WORKSPACE}/.nuget"
    sh "mkdir -p '${nugetHomeHost}/packages' '${nugetHomeHost}/NuGet' || true"

    // Will be computed AFTER loading the shared library
    def dockerArgs = null

    // Standard .NET CI env
    def dotnetEnv = [
        "HOME=/home/jenkins",
        "DOTNET_CLI_HOME=/home/jenkins",
        "DOTNET_SKIP_FIRST_TIME_EXPERIENCE=1",
        "DOTNET_CLI_TELEMETRY_OPTOUT=1",
        "NUGET_PACKAGES=/home/jenkins/.nuget/packages"
    ]

    // --- Proxy propagation: gather from controller env ---
    def proxyEnv = []
    if (env.http_proxy)  proxyEnv << "http_proxy=${env.http_proxy}"
    if (env.https_proxy) proxyEnv << "https_proxy=${env.https_proxy}"
    if (env.no_proxy)    proxyEnv << "no_proxy=${env.no_proxy}"
    if (env.HTTP_PROXY)  proxyEnv << "HTTP_PROXY=${env.HTTP_PROXY}"
    if (env.HTTPS_PROXY) proxyEnv << "HTTPS_PROXY=${env.HTTPS_PROXY}"
    if (env.NO_PROXY)    proxyEnv << "NO_PROXY=${env.NO_PROXY}"

    timestamps {
        try {
            stage('Checkout') {
                checkout scm
                sh 'git rev-parse --short HEAD || true'
            }

            stage('Load Shared Library') {
                // If your lib is public, you can omit credentialsId
                library identifier: 'jenkins-shared-library@main', retriever: modernSCM([
                    $class: 'GitSCMSource',
                    remote: 'https://github.com/agileqatester/jenkins-shared-libs.git',
                    credentialsId: 'git-agiletester'
                ])
                echo 'Shared library loaded.'
            }

            stage('Init Agent & Compose dockerArgs') {
                echo "Using build image: ${buildImage}"

                script {
                    // dockerGid must match your host’s /var/run/docker.sock group (you verified it’s 991)
                    def dockerArgsBase = nugetDockerArgs(
                        nugetHomeHost: nugetHomeHost,
                        nugetHomeContainer: '/home/jenkins/.nuget',
                        dockerGid: 991
                    )

                    // Extend with -e flags for proxy passthrough into the inner container
                    dockerArgs = dockerArgsBase +
                        (env.http_proxy  ? " -e http_proxy=${env.http_proxy}"     : "") +
                        (env.https_proxy ? " -e https_proxy=${env.https_proxy}"   : "") +
                        (env.no_proxy    ? " -e no_proxy=${env.no_proxy}"         : "") +
                        (env.HTTP_PROXY  ? " -e HTTP_PROXY=${env.HTTP_PROXY}"     : "") +
                        (env.HTTPS_PROXY ? " -e HTTPS_PROXY=${env.HTTPS_PROXY}"   : "") +
                        (env.NO_PROXY    ? " -e NO_PROXY=${env.NO_PROXY}"         : "")
                }
                echo "dockerArgs composed."
            }

            // Prepare NuGet mount permissions using your shared step (now available)
            stage('NuGet Prep') {
                dotnetNugetPrep(
                    image: buildImage,
                    dockerArgs: dockerArgs,                          // includes socket, group, nuget mount, and proxies
                    nugetHomeHost: nugetHomeHost,
                    nugetHomeContainer: '/home/jenkins/.nuget',
                    uid: 1000,
                    gid: 1000
                )
            }

            stage('Preflight') {
                withEnv(dotnetEnv + proxyEnv) {
                    docker.image(buildImage).inside(dockerArgs) {
                        sh """
                          set -eux
                          echo '=== Preflight ==='
                          whoami; id
                          echo HOME=\$HOME
                          env | egrep -i 'http_proxy|https_proxy|no_proxy' || true

                          # Verify Docker client/server
                          which docker
                          docker version
                          docker buildx version || true

                          # Quick network probe to NuGet (via proxy if present)
                          curl -I --max-time 20 https://api.nuget.org/v3/index.json

                          # .NET SDK checks
                          dotnet --info || true
                          dotnet --list-sdks || true

                          echo '== Workspace =='; pwd
                          echo '== Top-level =='; ls -la
                          echo '== Project dir =='; ls -la ${projDir}
                          test -d ${projDir}
                          test -f ${dockerfile}

                          # Confirm we can write into NuGet config dir
                          touch /home/jenkins/.nuget/NuGet/.writetest && rm /home/jenkins/.nuget/NuGet/.writetest
                          echo '=== Preflight OK ==='
                        """
                    }
                }
            }

            stage('Build (.NET)') {
                withEnv(dotnetEnv + proxyEnv) {
                    docker.image(buildImage).inside(dockerArgs) {
                        dir(projDir) {
                            sh '''
                              set -eux
                              dotnet restore
                              dotnet build --configuration Release
                            '''
                        }
                    }
                }
            }

        stage('Docker Build & Push (App)') {
        // BuildKit on unless explicitly disabled; buildx optional
        def bk        = (params?.USE_BUILDKIT == null || params.USE_BUILDKIT) ? '1' : '0'
        def useBuildx = (params?.USE_BUILDX == true)

        // Create nuget.config for BuildKit secret (preferred: credentials; fallback: proxyEnv)
        withCredentials([
            string(credentialsId: 'corp-proxy-url', variable: 'PROXY_URL'),
            string(credentialsId: 'corp-no-proxy',  variable: 'NO_PROXY_LIST')
        ]) {
            writeFile file: 'nuget.config', text: """<configuration>
        <config>
            <add key="http_proxy"  value="${PROXY_URL}"/>
            <add key="https_proxy" value="${PROXY_URL}"/>
            <add key="no_proxy"    value="${NO_PROXY_LIST}"/>
        </config>
        </configuration>
        """
        }

        withEnv(dotnetEnv + proxyEnv + ["DOCKER_BUILDKIT=${bk}"]) {
            docker.image(buildImage).inside(dockerArgs) {
            withCredentials([usernamePassword(
                credentialsId: 'docker-hub-agileqa',
                usernameVariable: 'DOCKER_USER',
                passwordVariable: 'DOCKER_PASS')]) {

                // Build reference + (optional) fallback tag
                if (!tag?.trim()) { tag = env.BUILD_NUMBER }
                def fullRef = "${repo}:${tag}"

                sh '''#!/usr/bin/env bash
        set -Eeuo pipefail

        echo "==> Docker login (hub)"
        echo "$DOCKER_PASS" | docker login -u "$DOCKER_USER" --password-stdin

        if [[ "''' + useBuildx.toString() + '''" == "true" ]]; then
        echo "==> Using buildx with BuildKit (load into local engine)"
        docker buildx create --use --name jxbuilder || true
        docker buildx inspect --bootstrap
        docker buildx build --progress=plain --load \
            --secret id=nuget_config,src=nuget.config \
            -t __FULL_REF__ \
            -f __DOCKERFILE__ __BUILDCXT__
        else
        echo "==> Using classic docker build (BuildKit: ${DOCKER_BUILDKIT:-0})"
        docker build --progress=plain \
            --secret id=nuget_config,src=nuget.config \
            -t __FULL_REF__ \
            -f __DOCKERFILE__ __BUILDCXT__
        fi

        echo "==> Pushing tag: __FULL_REF__"
        docker push __FULL_REF__

        if [[ "__TAG__" != "latest" ]]; then
        echo "==> Tagging + pushing 'latest'"
        docker tag __FULL_REF__ __REPO__:latest
        docker push __REPO__:latest
        fi

        docker logout || true
        '''  // <<< single-quoted heredoc kept
        .replace('__FULL_REF__', fullRef)
        .replace('__DOCKERFILE__', dockerfile)
        .replace('__BUILDCXT__',  buildCtx)
        .replace('__REPO__',      repo)
        .replace('__TAG__',       tag)

                // History gate (single quotes; inject fullRef at runtime)
                sh '''
                set -e
                docker history __FULL_REF__ --no-trunc | tee history.txt
                if grep -Eiq '(http_proxy|https_proxy|genproxy|amdocs)' history.txt; then
                    echo 'ERROR: Proxy strings found in image history!' 1>&2
                    exit 1
                fi
                '''.replace('__FULL_REF__', fullRef)

                // Clean sensitive files
                sh 'rm -f nuget.config history.txt || true'
            }
            }
        }
        }
                    
        stage('Deploy Locally') {
        withEnv([
            "REPO=${repo}",
            "TAG=${tag}"
        ]) {
            docker.image(buildImage).inside('--group-add 991 -v /var/run/docker.sock:/var/run/docker.sock --add-host=host.docker.internal:host-gateway') {
            sh '''#!/usr/bin/env bash
        set -Eeuo pipefail

        echo "==> Who am I and what are socket perms?"
        id
        ls -l /var/run/docker.sock || true

        echo "==> Using image: ${REPO}:${TAG}"
        IMG_ID=$(docker image inspect "${REPO}:${TAG}" --format '{{.Id}}')
        echo "${IMG_ID}"

        EXPOSED=$(docker image inspect "${REPO}:${TAG}" --format '{{json .Config.ExposedPorts}}')
        echo "ExposedPorts: ${EXPOSED}"
        if [[ -z "${EXPOSED}" || "${EXPOSED}" == "null" || "${EXPOSED}" == "{}" || "${EXPOSED}" != *"80/tcp"* ]]; then
        echo "ERROR: Image ${REPO}:${TAG} does not EXPOSE 80/tcp" 1>&2
        exit 1
        fi

        echo "==> Cleaning previous container if any"
        docker rm -f dotnet_sample_container || true

        echo "==> Starting web container and publishing EXPOSEd ports (-P)"
        cid=$(docker run -d --cap-add NET_BIND_SERVICE --name dotnet_sample_container -P "${REPO}:${TAG}")

        # Brief pause to ensure NetworkSettings.Ports populated
        sleep 1

        echo "==> docker ps:"
        docker ps --format 'table {{.Names}}\t{{.Ports}}\t{{.Status}}'

        echo "==> Getting mapped host port via docker inspect (single value)"
        mapped=$(docker inspect -f '{{(index (index .NetworkSettings.Ports "80/tcp") 0).HostPort}}' dotnet_sample_container || true)
        mapped=$(printf "%s" "${mapped}" | tr -d '\r\n')
        if [[ -z "${mapped}" ]]; then
        echo "ERROR: No public port found for 80/tcp" 1>&2
        echo "Diagnostics:"
        docker inspect dotnet_sample_container --format '{{json .HostConfig.PortBindings}}' || true
        docker inspect dotnet_sample_container --format '{{json .NetworkSettings.Ports}}' || true
        docker logs dotnet_sample_container || true
        exit 1
        fi
        echo "==> Mapped host port: ${mapped}"

        # From inside the build container, reach host via host.docker.internal
        APP_URL="http://host.docker.internal:${mapped}"
        echo "APP_URL=${APP_URL}" | tee app_url.properties
        echo "APP_URL=${APP_URL}"

        echo "==> Probing readiness (try /health then /)"
        ready=0
        for i in {1..30}; do
        if curl -fsS "${APP_URL}/health" >/dev/null 2>&1; then
            echo "Health endpoint OK at ${APP_URL}/health"
            ready=1
            break
        elif curl -fsS "${APP_URL}/" >/dev/null 2>&1; then
            echo "Root endpoint OK at ${APP_URL}/"
            ready=1
            break
        fi
        sleep 1
        done

        if [[ "${ready}" -ne 1 ]]; then
        echo "App did not become ready in time" 1>&2
        docker logs dotnet_sample_container || true
        exit 1
        fi
        '''
            }

            // Archive after inside{} so Jenkins can collect from the workspace
            archiveArtifacts artifacts: 'app_url.properties', fingerprint: true, onlyIfSuccessful: true
            }
        }

        } catch (err) {
            currentBuild.result = 'FAILURE'
            echo "Pipeline failed: ${err}"
            throw err
        } finally {
            stage('Cleanup') {
                docker.image(buildImage).inside(dockerArgs ?: '') {
                    sh 'set -eux; docker image ls | head -n 20 || true'
                }
            }
        }
    }
}