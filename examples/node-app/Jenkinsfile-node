@Library('jenkins-shared-library@main') _

/**
 * Node.js pipeline using a containerized multi-tool agent.
 * - Uses host network for corporate DNS, and host Docker daemon via socket mount.
 * - Reuses shared library steps and prevents proxy info from leaking into the image.
 *
 * Image repo: agileqa/node-sample
 * Workdir   : examples/node-app
 * Dockerfile: examples/node-app/Dockerfile
 */

def proxyEnv         = [:]
def repo             = 'agileqa/node-sample'
def tag              = ''
def projDir          = 'examples/node-app'
def dockerfile       = ''
def buildCtx         = '.'
def npmCacheHost     = ''
def innerDockerArgs  = '' // for preflightCheck's inside()

pipeline {
    agent {
        docker {
            image 'agileqa/jenkins-agent:multi-tool'
            // Use host network so corporate DNS works; mount Docker socket; add docker group GID.
            // IMPORTANT: Replace 991 with your host's docker group GID if different.
            args  '--network host -v /var/run/docker.sock:/var/run/docker.sock --group-add 991'
            reuseNode true
        }
    }

    options {
        skipDefaultCheckout(true)
        timestamps()
        ansiColor('xterm')
    }

    parameters {
        // Build toggles
        booleanParam(name: 'USE_BUILDKIT', defaultValue: true,  description: 'Enable Docker BuildKit')
        booleanParam(name: 'USE_BUILDX',   defaultValue: false, description: 'Use docker buildx (multi-arch)')
        string(name: 'IMAGE_TAG', defaultValue: '', description: 'Optional override (defaults to "latest")')

        // Proxy inputs (set here OR rely on Jenkins global env)
        string(name: 'HTTP_PROXY',  defaultValue: '', description: 'http://user:pass@proxy-host:port (or http://proxy-host:port)')
        string(name: 'HTTPS_PROXY', defaultValue: '', description: 'http://user:pass@proxy-host:port')
        string(name: 'NO_PROXY',    defaultValue: '', description: 'localhost,127.0.0.1,.corp.local')
    }

    // Make proxy vars available inside the agent container
    environment {
        DOCKERHUB_REPO = 'agileqa/node-sample'

        // Prefer job params; fallback to Jenkins global env if set
        HTTP_PROXY  = "${params.HTTP_PROXY  ?: env.HTTP_PROXY  ?: ''}"
        HTTPS_PROXY = "${params.HTTPS_PROXY ?: env.HTTPS_PROXY ?: ''}"
        NO_PROXY    = "${params.NO_PROXY    ?: env.NO_PROXY    ?: ''}"

        // Lowercase variants (some tools prefer these)
        http_proxy  = "${HTTP_PROXY}"
        https_proxy = "${HTTPS_PROXY}"
        no_proxy    = "${NO_PROXY}"
    }

    stages {
        stage('Checkout') {
            steps { checkout scm }
        }

        stage('Init') {
            steps {
                script {
                    proxyEnv    = collectProxyEnv() // gathers both UPPER/lower-case vars
                    tag         = env.IMAGE_TAG?.trim() ? env.IMAGE_TAG.trim() : 'latest'
                    dockerfile  = "${projDir}/Dockerfile"

                    npmCacheHost = "${env.WORKSPACE}/.npm"
                    sh "mkdir -p '${npmCacheHost}'"

                    // inner container for preflight also needs host net + docker socket + cache
                    innerDockerArgs = "--network host -v /var/run/docker.sock:/var/run/docker.sock --group-add 991 -v ${npmCacheHost}:/home/node/.npm"

                    // visibility (safe)
                    echo "HTTP_PROXY=${env.HTTP_PROXY ?: ''}"
                    echo "HTTPS_PROXY=${env.HTTPS_PROXY ?: ''}"
                    echo "NO_PROXY=${env.NO_PROXY ?: ''}"
                }
            }
        }

        stage('Preflight') {
            steps {
                script {
                    // Proxy-aware preflight
                    withEnv(proxyEnv) {
                        preflightCheck(
                            image     : 'agileqa/jenkins-agent:multi-tool',
                            dockerArgs: innerDockerArgs,
                            workDir   : projDir
                        )
                    }
                }
            }
        }

        stage('Build (Node)') {
            steps {
                script {
                    // IMPORTANT:
                    // - Use proxy env from collectProxyEnv()
                    // - Expand NPM_CONFIG_* with REAL values using GStrings ("${...}")
                    // - Clear NO_PROXY here so npm does not bypass the proxy for public registries
                    withEnv(
                        proxyEnv + [
                            "NPM_CONFIG_PROXY=${env.HTTP_PROXY}",
                            "NPM_CONFIG_HTTPS_PROXY=${env.HTTPS_PROXY}",
                            'NO_PROXY=',
                            'no_proxy='
                        ]
                    ) {
                        dir(projDir) {
                            sh '''
                              set -eux

                              echo "== proxy env for npm =="
                              env | grep -i proxy || true

                              # Also set npm's own config explicitly (redundant but safe)
                              if [ -n "${HTTP_PROXY:-}" ]; then npm config set proxy "$HTTP_PROXY"; fi
                              if [ -n "${HTTPS_PROXY:-}" ]; then npm config set https-proxy "$HTTPS_PROXY"; fi
                              npm config delete noproxy || true
                              npm config set noproxy "" || true

                              echo "== npm proxy config =="
                              npm config get proxy || true
                              npm config get https-proxy || true
                              npm config get noproxy || true
                            '''
                            // Shared lib: npm install && npm run build
                            runBuild('node')
                        }
                    }
                }
            }
        }

        stage('Docker Build & Push') {
            steps {
                script {
                    // Pass proxy as runtime env only; your shared lib also scans history for leaks.
                    dockerBuildPush(
                        image       : repo,
                        tag         : tag,
                        dockerfile  : dockerfile,
                        context     : buildCtx,
                        useBuildx   : params.USE_BUILDX,
                        useBuildKit : params.USE_BUILDKIT,
                        proxyEnv    : proxyEnv
                        // secretFiles: ['.npmrc'] // enable if you later add private npm auth
                    )
                }
            }
        }

        stage('Deploy Locally') {
            steps {
                script {
                    // Assumes container serves on port 80 and exposes /health
                    // If your Node app uses 3000, I can extend deployContainer to accept ports & healthPath.
                    deployContainer(image: "${repo}:${tag}", containerName: 'node_sample_container')
                }
            }
        }
    }

    post {
        always {
            echo "Build finished for ${repo}:${tag}"
        }
    }
}