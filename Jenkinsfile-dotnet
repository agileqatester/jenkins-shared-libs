node {
    // --- Pipeline parameters to control Docker build behavior ---
    properties([parameters([
        booleanParam(name: 'USE_BUILDKIT', defaultValue: true,  description: 'Enable Docker BuildKit'),
        booleanParam(name: 'USE_BUILDX',   defaultValue: false, description: 'Use docker buildx explicitly (requires buildx plugin in agent)')
    ])])

    // === Image + App configuration ===
    def buildImage = 'agileqa/jenkins-agent:multi-tool'        // your toolbox image (now includes buildx)
    def repo       = 'agileqa/dotnet-sample'                   // Docker Hub app repo
    def tag        = env.IMAGE_TAG ?: 'latest'                 // image tag

    // .NET app layout in this repo
    def projDir    = 'examples/dotnet-app'                     // contains DotnetApp.csproj
    def dockerfile = 'examples/dotnet-app/Dockerfile'          // app Dockerfile
    def buildCtx   = '.'                                       // keep root context

    // Host-side NuGet HOME under workspace (will be mounted later)
    def nugetHomeHost = "${env.WORKSPACE}/.nuget"
    sh "mkdir -p '${nugetHomeHost}/packages' '${nugetHomeHost}/NuGet' || true"

    // Will be computed AFTER loading the shared library
    def dockerArgs = null

    // Standard .NET CI env
    def dotnetEnv = [
        "HOME=/home/jenkins",
        "DOTNET_CLI_HOME=/home/jenkins",
        "DOTNET_SKIP_FIRST_TIME_EXPERIENCE=1",
        "DOTNET_CLI_TELEMETRY_OPTOUT=1",
        "NUGET_PACKAGES=/home/jenkins/.nuget/packages"
    ]

    // --- Proxy propagation: gather from controller env ---
    def proxyEnv = []
    if (env.http_proxy)  proxyEnv << "http_proxy=${env.http_proxy}"
    if (env.https_proxy) proxyEnv << "https_proxy=${env.https_proxy}"
    if (env.no_proxy)    proxyEnv << "no_proxy=${env.no_proxy}"
    if (env.HTTP_PROXY)  proxyEnv << "HTTP_PROXY=${env.HTTP_PROXY}"
    if (env.HTTPS_PROXY) proxyEnv << "HTTPS_PROXY=${env.HTTPS_PROXY}"
    if (env.NO_PROXY)    proxyEnv << "NO_PROXY=${env.NO_PROXY}"

    timestamps {
        try {
            stage('Checkout') {
                checkout scm
                sh 'git rev-parse --short HEAD || true'
            }

            stage('Load Shared Library') {
                // If your lib is public, you can omit credentialsId
                library identifier: 'jenkins-shared-library@main', retriever: modernSCM([
                    $class: 'GitSCMSource',
                    remote: 'https://github.com/agileqatester/jenkins-shared-libs.git',
                    credentialsId: 'git-agiletester'
                ])
                echo 'Shared library loaded.'
            }

            stage('Init Agent & Compose dockerArgs') {
                echo "Using build image: ${buildImage}"

                script {
                    // dockerGid must match your host’s /var/run/docker.sock group (you verified it’s 991)
                    def dockerArgsBase = nugetDockerArgs(
                        nugetHomeHost: nugetHomeHost,
                        nugetHomeContainer: '/home/jenkins/.nuget',
                        dockerGid: 991
                    )

                    // Extend with -e flags for proxy passthrough into the inner container
                    dockerArgs = dockerArgsBase +
                        (env.http_proxy  ? " -e http_proxy=${env.http_proxy}"     : "") +
                        (env.https_proxy ? " -e https_proxy=${env.https_proxy}"   : "") +
                        (env.no_proxy    ? " -e no_proxy=${env.no_proxy}"         : "") +
                        (env.HTTP_PROXY  ? " -e HTTP_PROXY=${env.HTTP_PROXY}"     : "") +
                        (env.HTTPS_PROXY ? " -e HTTPS_PROXY=${env.HTTPS_PROXY}"   : "") +
                        (env.NO_PROXY    ? " -e NO_PROXY=${env.NO_PROXY}"         : "")
                }
                echo "dockerArgs composed."
            }

            // Prepare NuGet mount permissions using your shared step (now available)
            stage('NuGet Prep') {
                dotnetNugetPrep(
                    image: buildImage,
                    dockerArgs: dockerArgs,                          // includes socket, group, nuget mount, and proxies
                    nugetHomeHost: nugetHomeHost,
                    nugetHomeContainer: '/home/jenkins/.nuget',
                    uid: 1000,
                    gid: 1000
                )
            }

            stage('Preflight') {
                withEnv(dotnetEnv + proxyEnv) {
                    docker.image(buildImage).inside(dockerArgs) {
                        sh """
                          set -eux
                          echo '=== Preflight ==='
                          whoami; id
                          echo HOME=\$HOME
                          env | egrep -i 'http_proxy|https_proxy|no_proxy' || true

                          # Verify Docker client/server
                          which docker
                          docker version
                          docker buildx version || true

                          # Quick network probe to NuGet (via proxy if present)
                          curl -I --max-time 20 https://api.nuget.org/v3/index.json

                          # .NET SDK checks
                          dotnet --info || true
                          dotnet --list-sdks || true

                          echo '== Workspace =='; pwd
                          echo '== Top-level =='; ls -la
                          echo '== Project dir =='; ls -la ${projDir}
                          test -d ${projDir}
                          test -f ${dockerfile}

                          # Confirm we can write into NuGet config dir
                          touch /home/jenkins/.nuget/NuGet/.writetest && rm /home/jenkins/.nuget/NuGet/.writetest
                          echo '=== Preflight OK ==='
                        """
                    }
                }
            }

            stage('Build (.NET)') {
                withEnv(dotnetEnv + proxyEnv) {
                    docker.image(buildImage).inside(dockerArgs) {
                        dir(projDir) {
                            sh '''
                              set -eux
                              dotnet restore
                              dotnet build --configuration Release
                            '''
                        }
                    }
                }
            }

            stage('Docker Build & Push (App)') {
                // Enable/disable BuildKit via parameter; optionally switch to buildx path
                def bk = (params?.USE_BUILDKIT == null || params.USE_BUILDKIT) ? '1' : '0'
                def useBuildx = (params?.USE_BUILDX == true)

                withEnv(dotnetEnv + proxyEnv + ["DOCKER_BUILDKIT=${bk}"]) {
                    docker.image(buildImage).inside(dockerArgs) {
                        withCredentials([usernamePassword(credentialsId: 'docker-hub-agileqa',
                                                        usernameVariable: 'DOCKER_USER',
                                                        passwordVariable: 'DOCKER_PASS')]) {
                            sh """#!/usr/bin/env bash
            set -Eeuo pipefail

            # Login (secure)
            echo "\$DOCKER_PASS" | docker login -u "\$DOCKER_USER" --password-stdin

            # Compose proxy build args (only pass what exists)
            proxyArgs=""
            [[ -n "\${http_proxy:-}"  ]] && proxyArgs="\$proxyArgs --build-arg http_proxy=\$http_proxy"
            [[ -n "\${https_proxy:-}" ]] && proxyArgs="\$proxyArgs --build-arg https_proxy=\$https_proxy"
            [[ -n "\${no_proxy:-}"    ]] && proxyArgs="\$proxyArgs --build-arg no_proxy=\$no_proxy"
            [[ -n "\${HTTP_PROXY:-}"  ]] && proxyArgs="\$proxyArgs --build-arg HTTP_PROXY=\$HTTP_PROXY"
            [[ -n "\${HTTPS_PROXY:-}" ]] && proxyArgs="\$proxyArgs --build-arg HTTPS_PROXY=\$HTTPS_PROXY"
            [[ -n "\${NO_PROXY:-}"    ]] && proxyArgs="\$proxyArgs --build-arg NO_PROXY=\$NO_PROXY"

            if [[ "${useBuildx}" == "true" ]]; then
            # Ensure a builder exists and is active
            docker buildx create --use --name jxbuilder || true
            docker buildx inspect --bootstrap

            # Build with Buildx and LOAD into the local engine (needed for Deploy Locally)
            docker buildx build --progress=plain --load \$proxyArgs \
                -t ${repo}:${tag} \
                -f ${dockerfile} ${buildCtx}
            else
            # Classic docker build (BuildKit on/off via DOCKER_BUILDKIT env)
            docker build --progress=plain \$proxyArgs \
                -t ${repo}:${tag} \
                -f ${dockerfile} ${buildCtx}
            fi

            # Push tags
            docker push ${repo}:${tag}
            if [[ "${tag}" != "latest" ]]; then
            docker tag ${repo}:${tag} ${repo}:latest
            docker push ${repo}:latest
            fi

            docker logout || true
            """
                        }
                    }
                }
            }
            
  stage('Deploy Locally') {
    // If you already define repo/tag earlier in the pipeline, keep those.
    withEnv([
      "REPO=${repo}",
      "TAG=${tag}"
    ]) {
      // Run docker CLI inside the build container with access to host Docker and host gateway
      docker.image(buildImage).inside('--group-add 991 -v /var/run/docker.sock:/var/run/docker.sock --add-host=host.docker.internal:host-gateway') {
        sh '''#!/usr/bin/env bash
set -Eeuo pipefail

echo "==> Who am I and what are socket perms?"
id
ls -l /var/run/docker.sock || true

echo "==> Using image: ${REPO}:${TAG}"
IMG_ID=$(docker image inspect "${REPO}:${TAG}" --format '{{.Id}}')
echo "${IMG_ID}"

EXPOSED=$(docker image inspect "${REPO}:${TAG}" --format '{{json .Config.ExposedPorts}}')
echo "ExposedPorts: ${EXPOSED}"
if [[ -z "${EXPOSED}" || "${EXPOSED}" == "null" || "${EXPOSED}" == "{}" || "${EXPOSED}" != *"80/tcp"* ]]; then
  echo "ERROR: Image ${REPO}:${TAG} does not EXPOSE 80/tcp" >&2
  exit 1
fi

echo "==> Cleaning previous container if any"
docker rm -f dotnet_sample_container || true

echo "==> Starting web container and publishing EXPOSEd ports (-P)"
cid=$(docker run -d --name dotnet_sample_container -P "${REPO}:${TAG}")

# Brief pause to ensure NetworkSettings.Ports populated
sleep 1

echo "==> docker ps:"
docker ps --format 'table {{.Names}}\t{{.Ports}}\t{{.Status}}'

echo "==> Getting mapped host port via docker inspect (single value)"
mapped=$(docker inspect -f '{{(index (index .NetworkSettings.Ports "80/tcp") 0).HostPort}}' dotnet_sample_container || true)
mapped=$(printf "%s" "${mapped}" | tr -d '\\r\\n')
if [[ -z "${mapped}" ]]; then
  echo "ERROR: No public port found for 80/tcp" >&2
  echo "Diagnostics:"
  docker inspect dotnet_sample_container --format '{{json .HostConfig.PortBindings}}' || true
  docker inspect dotnet_sample_container --format '{{json .NetworkSettings.Ports}}' || true
  docker logs dotnet_sample_container || true
  exit 1
fi
echo "==> Mapped host port: ${mapped}"

# Inside the build container, reach host via host.docker.internal (added by --add-host)
APP_URL="http://host.docker.internal:${mapped}"
echo "APP_URL=${APP_URL}" | tee app_url.properties
echo "APP_URL=${APP_URL}"

echo "==> Probing readiness (try /health then /)"
ready=0
for i in {1..30}; do
  if curl -fsS "${APP_URL}/health" >/dev/null 2>&1; then
    echo "Health endpoint OK at ${APP_URL}/health"
    ready=1
    break
  elif curl -fsS "${APP_URL}/" >/dev/null 2>&1; then
    echo "Root endpoint OK at ${APP_URL}/"
    ready=1
    break
  fi
  sleep 1
done

if [[ "${ready}" -ne 1 ]]; then
  echo "App did not become ready in time" >&2
  docker logs dotnet_sample_container || true
  exit 1
fi
'''
      }

      // Archive after inside{} so Jenkins can collect from the workspace
      archiveArtifacts artifacts: 'app_url.properties', fingerprint: true, onlyIfSuccessful: true
    }
  }

        } catch (err) {
            currentBuild.result = 'FAILURE'
            echo "Pipeline failed: ${err}"
            throw err
        } finally {
            stage('Cleanup') {
                docker.image(buildImage).inside(dockerArgs ?: '') {
                    sh 'set -eux; docker image ls | head -n 20 || true'
                }
            }
        }
    }
}